# CPU 기초

## 명령어 주소지정(Addressing Mode) 방식

* 정해진 명령어의 비트들은 **그 수에 있어서 매우 제한적**이다.
* 그 안에 오퍼랜드들 만으로 메모리를 지정하는 것은 매우 제한적이다.
* 더 큰 용량의 메모리에 접근하기 위해서는 직접 또는 간접으로 다양한 방법이 요구된다.
* 이미 설계된 CPU의 종류마다 그 수 가 매우 다양하고 다르게 제안되어 있다.

### 용어

* M[`x`]: 메모리의 x번지의 내용
* `A`: 주소
* R`i`: 레지스터 번호
* [R`i`]: 레지스터의 내용
* D: 변위
* ea: 유효 주소(effect address), 계산된 실제 주소
* addr: address
* imm: immediate value

### 즉치(immediate addressing mode)

* 프로그램에서 상수 값으로 사용된다.
* 명령어 내의 오퍼랜드가 실제 데이터가 되는 것을 의미한다.
* CPU는 메모리로부터 데이터를 인출하는 과정이 필요 없다. (ea가 필요 없음)

#### ex)

```
MOV     R1, #8          ;R1 <- 8
ADD     R2, #9          ;R2 <- R2 + 9
```

### 묵시적(implied addressing mode)

* 명령어 내에 필요한 데이터의 위치를 지정하지 않는다.
* 쉬프트 연산이나 스택에 관련된 연산에 사용된다.
* Sp가 ea가 된다.

#### ex)

```
ASL     2               ;AC <- AC << 2
PUSH    R2              ;M[Sp] <- R2
```

### 직접(direct addressing mode)

* 절대 주소지정(absolute addressing mode)이라고도 한다.
* 명령어 내에 오퍼랜드가 주소 정보로 사용되어 매모래 내 필요한 데이터의 위치를 지정한다.

#### ex)

```
MOV     R1, 5           ;R1 <- M[5]
ADD     R2, 5           ;R2 <- R2 + M[5]
```

### 간접(indirect addressing mode)

* 직접주소지정 방식의 단점(주소 범위가 짧다)을 해결한다.
* 메모리 내의 데이터를 또 다른 주소 정보를 사용함으로써 더 큰 영역의 메모리 접근을 확보할 수 있다.
* 단점으로는 메모리 접근의 지연시간이 발생한다.

#### ex)

```
MOV     R1, (5)         ;R1 <- M[M[5]]
```

### 레지스터(register addressing mode)

* 연산에 사용될 데이터가 레지스터에 저장되어 있다.
* 오퍼랜드의 내용은 레지스터의 번호로 사용된다.
* 메모리 내의 데이터에 접근할 필요가 없다.
* 메모리 접근의 지연시간이 없다.

#### ex)

```
MOV     R1, R2          ;R1 <- R2
ADD     R3, R4          ;R3 <- R3 + R4
```

### 레지스터 간접(register indirect addressing mode)

* 오퍼랜드의 내용은 레지스터 번호로 사용된다.
* 오퍼랜드에서 지정한 내용이 메모리의 주소정보이다.
* 레지스터의 비트 수에 따라 지정할 수 있는 메모리 영역이 결정된다.

#### ex)

```
MOV     R1, (R2)        ;R1 <- M[R2]
ADD     R3, (R4)        ;R3 <- R3 + M[R4]
```

### 변위 (displacement addressing mode)

* 두 개의 오퍼랜드로 구성, 하나는 레지스터, 다른 하나는 변위로 사용된다.
* 유효주소는 지정된 레지스터의 내용에 변위를 합한것이다.
* 레지스터의 종류에 따라 상대(pc), 인덱스(index), 베이스(base)레지스터 주소지정 방식이라고 한다.

#### ex)

```
MOV     R1, 9(R2)       ;R1 <- M[[R2] + 9]
```
