# Database Storage 1

## Disk-oriented Architecture

* DBMS 가 데이터베이스의 기본 저장 위치가 비 휘발성 디스크에 있다고 가정한다.
* DBMS 의 컴포넌트들은 휘발성 디스크와 비 휘발성 디스크 사이의 데이터 이동을 관리한다.

## System Design Goal

* DBMS 가 사용 가능한 메모리의 양을 초과하는 데이터베이스를 관리할 수 있어야 한다.
* Read/Write 는 많은 비용을 치르므로 성능 저하를 피하기 위해 신중하게 관리할 수 있어햐 한다.

## Sequential VS. Random Access

* HDD 에서의 Random Access 는 Sequential Access 보다 느리다.
* 전통적인 DBMS 는 Seiquential Access 를 최대화하는 방향으로 디자인되었다.
    * 알고리즘은 랜덤한 Page 를 Write 하는 횟수를 줄이려 시도하기 때문에 데이터는 인접한 블록에 저장된다.
    * 동시에 다중 Page 를 할당하는 것을 `extent` 라고 한다.

## Why not use the OS?

* System Call 중 하나인 `mmap` 을 이용하여 파일의 내용을 프로세스의 Address 에 맵핑할 수 있다.
* `mmap` 을 사용하면 운영체제는 파일 페이지를 메모리 안팎으로 이동시키기 위한 데이터 이동을 담당한다.
* `OS의 Virtual Memory 의 공간 > Physical Memory 의 공간` 인 상태에서 Virtual Memory 만큼의 Page 를 Access 할 때, Physical Memory 는 이를 수용할 수 없게 되는 문제가 발생한다.

위 문제에 대한 몇가지 해결책이 있다.

* `madvise`: OS 에게 특정 페이지를 읽는 방법을 알려준다.
* `mlock`: 메모리 범위를 Page out 할 수 없다는 것을 OS 에게 알린다.
* `msync`: 메모리 범위를 디스크로 flush 하도록 OS 에게 지시한다.

이들을 모두 사용하는 DBMS

* `monetdb`: 고수준 Read-only 기반의 분석용 DB를 제공한다.
* `LMDB`

부분적으로 사용하는 DBMS

* `mongoDB`: 원래 엔진은 `mmap` 을 사용하도록 설계되었으나 Storage Manager 인 WiredTiger 기반으로 바뀌었다.
* `MEMSQL`: 컬럼 정보를 저장하거나 Read-only 인 정보를 불러올 때 사용한다.
* `SQLite`, `influxdb`: `mmap` 을 부분적으로 사용하는 다른 엔진을 사용한다.

DBMS 는 (대부분) 모든 작업을 통제하기를 원하며, 더 나은 작업을 할 수 있다.

* Dirty page (변경된 페이지)를 올바른 순서로 디스크에 flush
* Specialized prefetching
* Buffer 교체 정책
* Thread/Process scheduling

OS 는 DBMS 에게 있어 친구가 아니다.

## Database Storage

* 문제 #1: DBMS 는 어떻게 디스크에 있는 파일 속 데이터베이스를 표현하는가?
* 문제 #2: DBMS 는 어떻게 메모리를 관리하고, 디스크에서 데이터를 앞뒤(back-and-forth)로 이동시키는가?

## File Storage

* DBMS 는 디스크에 하나 이상의 파일을 사용하여 Database 를 저장한다.
* OS 는 이 파일에 대해 아무것도 알 수 없다.
    * 모든 표준 파일 시스템 보호(Standard filesystem protections)가 사용된다.
    * 1980 년대 초기 시스템은 Raw Storage 에 사용자 정의 파일 시스템을 사용했다.

## Storage Manager

* Storage Manager 는 Database 의 파일을 유지 및 관리한다.
* Storage Manager 는 파일을 Page collection 으로 구성한다.
    * Page 에 읽었거나 쓰인 데이터를 추적한다.
    * 사용가능한 공간(Avaliable space)를 추척한다.

## Database Pages

Page 는 fixed-size 데이터의 블록 단위이다.

* Tuples, 메타데이터, Indexes, 로그 기록들을 담을 수 있다.
* 대부분의 시스템은 Page type 을 혼합하지 않는다.
    * ex) 하나의 Page 에 Tuple 데이터와 Index 데이터를 동시에 담을 수 없다.
* 일부 시스템에서는 Page 가 자체 포함(self-contained)되어야 합니다.
    * ex) Dict 요소로 Dict Object 를 포함할 수 있는 것고 같은 형태

각각의 Page 는 고유한 식별자를 부여받는다.
    
* DBMS 는 물리적인 장소로 Page id 를 맵핑하기 위해 Indirection Layer 를 사용한다.

DBMS 에는 "pages" 에 대한 3가지 다른 개념이 있다.

* Hardware Page (usually 4KB)
* OS Page (usually 4KB)
* Database Page (1-16KB)
    * `SQLite`: 1KB
    * `DB2`, `Oracle`: 4KB
    * `SQL Server`, `PostgreSQL`: 8KB
    * `MySQL`: 16KB

Hardware Page 는 장치가 "안전한 쓰기(failsafe write)" 를 보장할 수 있는 수준을 의미한다.
