## Implicit Indexes

대부분의 DBMS 는 인덱스를 자동으로 생성하며 무결성 제약 조건(integrity constraints)을 적용시킨다.
* Primary Keys
* Unique Constraints
* Foreign Keys (?)

## Partial Indexes

전체 테이블의 서브셋에 대한 인덱스를 만든다.
이로 인해 잠재적으로 사이즈와 유지 관리 오버헤드가 줄어든다.

```sql
CREATE INDEX idx_foo ON foo (a, b) WHERE c = 'WuTang';
-- c 의 범위를 'WuTang' 으로 한정하므로 위 인덱스 사용이 가능
SELECT b FROM foo WHERE a = 123 AND c = 'WuTang';
```

일반적으로 사용하는 예시 중 하나는 부분적 날짜 범위를 인덱스로 잡는 것이다.
* Create a separate index per month, year.

## Covering Indexes

```sql
CREATE INDEX idx_foo ON foo (a, b);
-- 쿼리에서 a, b 필드만 엑세싱한다.
SELECT b FROM foo WHERE a = 123;
```

만약 쿼리 진행에 있어 필요한 모든 필드가 인덱싱이 가능하다면, DBMS 는 튜플을 탐색하지 않는다.
이로 인해 DBMS 의 Buffer pool 리소스 사용을 줄일 수 있다.

## Index Include Columns

```sql
CREATE INDEX idx_foo ON foo (a, b) INCLUDE (c);
```

index-only 쿼리를 지원하기 위해 인덱스에 추가적인 컬럼을 포함한다.

검색 키의 일부분이 아니다.

## Functional/Expression Indexes

이 인덱스는 기본 테이블과 동일한 방식으로 키를 저장할 필요가 없다.

```sql
SELECT * FROM users WHERE EXTRACT(dow FROM login) = 2;

CREATE INDEX idx_user_login ON users (login); -- X
```

인덱스를 선언할 때 expression 을 사용할 수 있다.

```sql
CREATE INDEX idx_user_login ON users (EXTRACT(dow FROM login));
CREATE INDEX idx_user_login ON foo (login) WHERE EXTRACT(dow FROM login) = 2;
```

## Observation

동적 순서 보존 인덱스(dynamic order-preserving index)를 구현하는 가장 쉬운 방법은 정렬된 링크드리스트를 사용하는 것이다.

모든 연산이 선형 검색으로 진행된다.
* Average Cost: `O(N)`

