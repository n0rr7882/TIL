## Implicit Indexes

대부분의 DBMS 는 인덱스를 자동으로 생성하며 무결성 제약 조건(integrity constraints)을 적용시킨다.
* Primary Keys
* Unique Constraints
* Foreign Keys (?)

## Partial Indexes

전체 테이블의 서브셋에 대한 인덱스를 만든다.
이로 인해 잠재적으로 사이즈와 유지 관리 오버헤드가 줄어든다.

```sql
CREATE INDEX idx_foo ON foo (a, b) WHERE c = 'WuTang';
-- c 의 범위를 'WuTang' 으로 한정하므로 위 인덱스 사용이 가능
SELECT b FROM foo WHERE a = 123 AND c = 'WuTang';
```

일반적으로 사용하는 예시 중 하나는 부분적 날짜 범위를 인덱스로 잡는 것이다.
* Create a separate index per month, year.

## Covering Indexes

```sql
CREATE INDEX idx_foo ON foo (a, b);
-- 쿼리에서 a, b 필드만 엑세싱한다.
SELECT b FROM foo WHERE a = 123;
```

만약 쿼리 진행에 있어 필요한 모든 필드가 인덱싱이 가능하다면, DBMS 는 튜플을 탐색하지 않는다.
이로 인해 DBMS 의 Buffer pool 리소스 사용을 줄일 수 있다.

## Index Include Columns

```sql
CREATE INDEX idx_foo ON foo (a, b) INCLUDE (c);
```

index-only 쿼리를 지원하기 위해 인덱스에 추가적인 컬럼을 포함한다.

검색 키의 일부분이 아니다.

