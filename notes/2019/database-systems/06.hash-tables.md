# Hash Tables

## Design Decisions

* Data Organization
    * 메모리/테이블 상의 데이터 구조를 어떻게 정의하고 어떤 정보가 저장되어야 효과적으로 접근하는 데 도움을 주는가
* Concurrency
    * 어떻게 충돌 문제 없이 여러 개의 쓰레드에서 데이터 구조에 동시에 잡근할 수 있게 하는가

## Hash Table 이란?

해시 테이블은 추상 데이터 타입을 key - value 형태로 맵핑하는 배열 자료구조이다.

해시 함수(hash function)을 사용하여 배열의 offset 을 계산하며 원하는 값을 찾을 수 있다.

* Design Decision #1: Hash Function
    * 어떻게 거대한 key 공간을 작은 도메인에 맵핑하는가
    * 속도 지향 vs. Collision rate 사이의 Trade-off
* Design Decision #2: Hashing Scheme
    * 해싱한 뒤의 key collision 을 어떻게 제어할 것인가
    * 넓은 해시 테이블 할당 vs. 키 검색/삽입을 위한 추가적인 과정 사이의 Trade-off

## Hash Functions

Hash table 의 join 에서는 cryptographic Hash function 을 사용하지 않는다.

속도가 빠르면서 낮은 collision rate 를 가지고 있어야 한다.

* MurmurHash (2008)
    * 빠른 속도를 가지도록 디자인되었으며, 범용 해시 함수이다.
* Google CityHash (2011)
    * MurmurHash2 의 아이디어를 바탕으로 디자인되었다.
    * 더욱 빠르며 짧은 키(<64 bytes)로 디자인 되었다.
* Google FarmHash (2014)
    * CityHash 의 새로운 버전이며 collision rate 가 더 낮아졌다.
* CLHash (2016)
    * carry-less multiplication 을 기초로 한 빠른 해싱 함수이다.

## Static Hashing Schemes

* Linear Probe Hashing
* Robin Hood Hashing
* Cuckoo Hashing

## Linear Probe Hashing

큰 슬롯 테이블을 가진다.

테이블의 다음 빈 슬롯을 선형으로 검색하여 충돌을 해결한다.
* 요소가 있는지 여부를 확인하기 위해 인덱스의 위치로 해싱해서 검색한다.
* 언제 스캔을 중지할지 알기 위해 인덱스에 키를 저장해야 한다.
* 삽입/삭제는 탐색의 일반화이다.

구조상 삭제가 일어나서는 안되며, Insert only 이고 heavy read 가 잦은 시스템에 적합하다.

### Non-unique keys

* Choice #1: Separate Linked List
    * 각 키에 대해 다른 저장공간으로 분리하여 값을 저장한다.
    * read 작업에 적합하지만 write 시 상대적으로 과정이 복잡하다.

* Choice #2: Redundant Keys
    * 해시 테이블에 중복된 키의 진입점을 같이 저장한다.
    * write 작업에 효과적이지만 read 시 스캔할 요소가 많아진다.

