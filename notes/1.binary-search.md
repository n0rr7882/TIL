# Binary Search

## 이진검색이란

* 정렬된 항목 목록에서 항목을 찾는 효율적인 알고리즘
* 가능한 위치를 하나만 좁힐 때까지 항목을 포함할 수 있는 부분의 절반을 반복적으로 나누어 작동

이진검색을 사용하는 가장 일반적인 방법 중 하나는 배열에서 항목을 찾는 것이다.

> 예) 2,539,913개의 별에 대한 정보를 포함하는 Tycho-2 별 카탈로그에서 특정 별을 검색하려고 가정하면, **선형 검색**이라는 알고리즘은 최악의 경우, 2,539,913개의 별을 모두 조사해야 할 수도 있지만, **이진 검색**은 최악의 경우에도 22개 이상의 절차를 가지지 않는다.

## 이진검색 설명하기

이진검색의 주된 아이디어는 합리적인 추측의 현재 범위를 추적하는 것이다.

Up-down 게임을 에로 들면, `25`에서 Up을 외치고 `81`에서 Down을 외쳤다면 그 다음 합당한 추측은 `26`에서 `80`사이의 숫자가 되는 것이다.

`26`과 `80`의 평균인 `53`을 제시, Down을 외치게 되면 다음 합당한 추측은 `26`과 `52` 사이에서 이루어지게 된다.

이 과정을 단계별로 정리하면 다음과 같다.

* `min` =  1, `max` = n
* `min`과 `max`의 평균을 반올림해 추측
* 추측한 숫자가 맞다면 종료
* 추측한 숫자가 낮다면 `min` = 추측한 숫자 + 1
* 추측한 숫자가 높다면 `max` = 추측한 숫자 - 1
* 다시 `min`과 `max`의 평균을 반올림해 추측

## 이진검색 구현하기

다음과 같이 소수를 담은 배열이 있다고 가정한다.
여기서 67이 소수인지 아닌지를 판단한다고 가정한다.

```py
primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
```

이 배열은 25개의 숫자를 포함하기 때문에 배열의 총길이는 25, `min` = 0, `max` = 24로 정의한 뒤 시작한다. 따라서 이진검색의 첫번째 추측은 (0 + 24) // 2인 `12`, 즉 배열의 12번째 인덱스에서 시작한다.

```py
primes[12] == 67 # 41 < 67
```

배열의 12번째 값 41은 찾고자 하는 값 67보다 낮다.
배열은 정렬되어있으므로 값 67이 만약 배열 내부에 존재한다면 인덱스 값은 12보다 더 높아야 한다. 그러므로 `min` = 현재 인덱스 + 1이 되고, `max`는 변경이 일어나지 않는다.

## 코드 구현하기

```py
# 배열과 검색하고자 하는 수 선언
array = [1..., 97]
target = 67

# 범위의 최소, 최대값 선언
min = 0
max = len(array) - 1

while True:
    # 범위가 존재하지 않으면 검색 대상이 없음
    if max < min:
        return -1
    
    # 최소, 최대범위 평균의 반올림
    guess = (min + max) // 2

    # 게싱한 인덱스 값이 맞으면 인덱스 반환
    if array[guess] == target:
        return guess

    # 게싱한 인덱스의 값이 작으면 최소범위 제한
    elif array[guess] < target:
        min = guess + 1

    # 게싱한 인덱스의 값이 크면 최대범위 제한
    elif array[guess] > target:
        max = guess - 1
```

## 실행시간

* 잘못된 추측을 할 때마다 합당한 추측의 범위를 절반으로 감소시킨다.
* 예로, 합당한 추측 범위에 32개 요소가 있는 경우, 잘못된 추측을 하면 범위가 16개로 줄어든다.
* 합당한 추측 범위 n개 요소가 있을 경우 추측 수는
    * n = 8일때, 4
    * n = 16일때, 5
    * n = 32일때, 6

이것을 log_2 n 수식으로 표현할 수 있다.
